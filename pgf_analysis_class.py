import numpy as np

class PGFAnalysis:
    """
    Class for performing PGF analysis on a process.
    """

    def g_X_1(self, s1, s2, lin, lout, pin):
        """
        Generating function for the number of offsprings generated
        by a single active individual of type 1.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - lin (float): average number of edges connecting nodes of type 1.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number of offsprigs
         generated by a single active individual of type 1.
        """
        ans = np.exp(lin * pin * (s1 - 1)) * np.exp(lout * pin * (s2 - 1))
        return ans


    def g_X_2(self, s1, s2, lin, lout, pin):
        """
        Generating function for the number of offsprings generated
        by a single active individual of type 2.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number of offsprigs
                      generated by a single active individual of type 2.
        """
        ans = np.exp(lin * pin * (s2 - 1)) * np.exp(lout * pin * (s1 - 1))
        return ans

    def gic_1(self, s1, s2):
        """
        Initial conditions for G_N_t.
        """
        return s1


    def G_N_t(self, s1, s2, t, lin, lout, pin):
        """
        Generating function for the number of offsprings
        in a network with two communities at generation t.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - t (int): Time point for which to calculate the generating function.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number
                       of offsprings in the system at time t.
        """
        if t > 0:  # have to iterate the pgf at least one
            for t_i in range(t, 0, -1):  # iterate the function t times
                new_s1 = self.g_X_1(s1, s2, lin, lout, pin)
                new_s2 = self.g_X_2(s1, s2, lin, lout, pin)
                s1 = new_s1
                s2 = new_s2
        ans = self.gic_1(s1, s2)  # apply initial conditions
        return ans

    def hazard_pgf_com1(self, t, lin, lout, pin):
        if t > 0:
            h = (self.G_N_t(0, 1, t, lin, lout, pin) - self.G_N_t(0, 0, t - 1, lin, lout, pin)) / (
                        1 - self.G_N_t(0, 0, t - 1, lin, lout, pin))
            # print('G_N_t(0,1,t): ', G_N_t(0,1,t,lin,lout,pin), 'G_N_t(0,1,t-1): ', G_N_t(0,1,t-1,lin,lout,pin), 'G_N_t(0,0,t-1): ', G_N_t(0,0,t-1,lin,lout,pin))
            # print('h:', h)
            return h
        else:
            return 0

    def hazard_pgf_com2(self, t, lin, lout, pin):
        if t > 0:
            h = (self.G_N_t(1, 0, t, lin, lout, pin) - self.G_N_t(0, 0, t - 1, lin, lout, pin)) / (
                        1 - self.G_N_t(0, 0, t - 1, lin, lout, pin))
            # print('G_N_t(0,1,t): ', G_N_t(0,1,t,lin,lout,pin), 'G_N_t(0,1,t-1): ', G_N_t(0,1,t-1,lin,lout,pin), 'G_N_t(0,0,t-1): ', G_N_t(0,0,t-1,lin,lout,pin))
            # print('h:', h)
            return h
        else:
            return 0

    def G_Y_t(self, s1, s2, t, lin=8, lout=2, pin=0.05):
        """
        Calculates the generating function for the number of offsprings
        in a network with two communities at generation t conditioned on survival.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - t (int): Time point for which to calculate the generating function.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number
                       of offsprings in the system at time t given its not a zero.
        """
        if t >= 0:
            # find the prob of process ending at t
            q_fun = self.G_N_t(0, 0, t, lin, lout, pin)

            # create pgf for G_Y_t by subtracting G_N_t_num and normalising it
            ans = (self.G_N_t(s1, s2, t, lin, lout, pin) - q_fun) / (1 - q_fun)
        else:
            ans = 0
        return ans

    # Hazard function
    def G_H_t(self, t, lin=8, lout=2, pin=0.05):
        """
        Hazard function for multi-type process on a network
        with two communities at generation t.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - t (int): Time point for which to calculate the generating function.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - probs_both (float): probability of a process to die
                            at exactly generation t in entire network.
        - probs_1 (float): probability of a process to die
                          at exactly generation t in community 1.
        - probs_2 (float): probability of a process to die
                        at exactly generation t in community 2.
        """

        if t >= 0:
            probs_both = self.G_Y_t(self.g_X_1(0, 0, lin, lout, pin),
                                    self.g_X_2(0, 0, lin, lout, pin),
                                    t - 1, lin, lout, pin)
            probs_1 = self.G_Y_t(self.g_X_1(0, 1, lin, lout, pin),
                                 self.g_X_2(0, 1, lin, lout, pin),
                                 t - 1, lin, lout, pin)
            probs_2 = self.G_Y_t(self.g_X_1(1, 0, lin, lout, pin),
                                 self.g_X_2(1, 0, lin, lout, pin),
                                 t - 1, lin, lout, pin)
        else:
            probs_both, probs_1, probs_2 = 0, 0, 0
        return probs_both, probs_1, probs_2

    def G_Y1_t(self, s1, s2, t, lin=8, lout=2, pin=0.05):
        if t >= 0:
            # create pgf for G_Y1_t by subtracting G_N_t_num and normalising it
            ans = (self.G_N_t(s1, s2, t, lin, lout, pin) - self.G_N_t(0, s2, t, lin, lout, pin)) / \
                  (1 - self.G_N_t(0, 1, t, lin, lout, pin))
        else:
            ans = 0
        return ans

    def G_Y2_t(self, s1, s2, t, lin=8, lout=2, pin=0.05):
        if t >= 0:
            # create pgf for G_Y1_t by subtracting G_N_t_num and normalising it
            ans = (self.G_N_t(s1, s2, t, lin, lout, pin) - self.G_N_t(s1, 0, t, lin, lout, pin))/\
                  (1 - self.G_N_t(1, 0, t, lin, lout, pin))

        else:
            ans = 0
        return ans

    def G_H1_t(self, s1, s2, t, lin=8, lout=2, pin=0.05):
        # Probability that process dies stops at exactly time t in community one, in the other
        # community it can keep going P(N1(t)=0 | N1(t-1) >0)
        if t > 0:
            probs = self.G_Y1_t(self.g_X_1(s1, s2, lin, lout, pin),
                                self.g_X_2(s1, s2, lin, lout, pin),
                                t-1, lin, lout, pin)
        else:
            probs = np.nan
        return probs

    def G_H2_t(self, s1, s2, t, lin=8, lout=2, pin=0.05):
        # Probability that process dies stops at exactly time t in community one, in the other
        # community it can keep going P(N2(t)=0 | N2(t-1) >0)
        if t > 0:
            probs = self.G_Y2_t(self.g_X_1(s1, s2, lin, lout, pin),
                                self.g_X_2(s1, s2, lin, lout, pin),
                                t-1, lin, lout, pin)
        else:

            probs = np.nan
        return probs

    def reinfection_community1_single_run(self, t, lin=8, lout=2, pin=0.05):
        # continuous extinction in community 1
        if t > 1:
            # community 1
            q1_t_m1 = self.G_N_t(0, 1, t-1, lin, lout, pin)
            q1 = self.G_N_t(0, 1, t, lin, lout, pin)
            h1_not_hazard = self.G_H1_t(0, 1, t, lin, lout, pin)
            c1 = (q1 - h1_not_hazard*(1 - q1_t_m1))/q1_t_m1
            r1 = 1 - c1
        if t == 0:
            r1 = 0
        if t == 1:
            r1 = 0
        return r1

    def reinfection_community2_single_run(self, t, lin=8, lout=2, pin=0.05):
        if t > 1:
            q2_t_m1 = self.G_N_t(1, 0, t-1, lin, lout, pin)
            q2 = self.G_N_t(1, 0, t, lin, lout, pin)
            h2_not_hazard = self.G_H2_t(1, 0, t, lin, lout, pin)
            c2 = (q2 - h2_not_hazard*(1 - q2_t_m1))/q2_t_m1
            r2 = 1 - c2

        if t == 0:
            r2 = 0

        if t == 1:
            r2 = 1 - self.G_N_t(1, 0, t, lin, lout, pin)
        return r2

    # def reinfection_community2_temp(self, t, lin=8, lout=2, pin=0.05):
    ## produces incorrect results
    #     if t > 1:
    #         q2_t_m1 = self.G_N_t(1, 0, t-1, lin, lout, pin)
    #         h2_not_hazard = self.G_H2_t(1, 0, t, lin, lout, pin)
    #         r2 = h2_not_hazard * (1 - 2 * q2_t_m1) / q2_t_m1
    #
    #     if t == 0:
    #         r2 = 0
    #
    #     if t == 1:
    #         r2 = 1 - self.G_N_t(1, 0, t, lin, lout, pin)
    #     return r2

    def reinfection(self, t, lin=8, lout=2, pin=0.05):
        if isinstance(t, int):
            r1 = self.reinfection_community1_single_run(t, lin, lout, pin)
            r2 = self.reinfection_community2_single_run(t, lin, lout, pin)
        if isinstance(t, list):
            r1 = []
            r2 = []
            for t_step in t:
                r1_i = self.reinfection_community1_single_run(t_step, lin, lout, pin)
                r2_i = self.reinfection_community2_single_run(t_step, lin, lout, pin)
                r1.append(r1_i)
                r2.append(r2_i)
        return r1, r2
