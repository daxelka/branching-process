import numpy as np

class PGFAnalysis:
    """
    Class for performing PGF analysis on a process.
    """

    def g_X_1(self, s1, s2, lin, lout, pin):
        """
        Generating function for the number of offsprings generated
        by a single active individual of type 1.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - lin (float): average number of edges connecting nodes of type 1.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number of offsprigs
         generated by a single active individual of type 1.
        """
        ans = np.exp(lin * pin * (s1 - 1)) * np.exp(lout * pin * (s2 - 1))
        return ans


    def g_X_2(self, s1, s2, lin, lout, pin):
        """
        Generating function for the number of offsprings generated
        by a single active individual of type 2.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number of offsprigs
                      generated by a single active individual of type 2.
        """
        ans = np.exp(lin * pin * (s2 - 1)) * np.exp(lout * pin * (s1 - 1))
        return ans

    def gic_1(self, s1, s2):
        """
        Initial conditions for G_N_t.
        """
        return s1


    def G_N_t(self, s1, s2, t, lin, lout, pin):
        """
        Generating function for the number of offsprings
        in a network with two communities at generation t.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - t (int): Time point for which to calculate the generating function.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number
                       of offsprings in the system at time t.
        """
        if t > 0:  # have to iterate the pgf at least one
            for t_i in range(t, 0, -1):  # iterate the function t times
                new_s1 = self.g_X_1(s1, s2, lin, lout, pin)
                new_s2 = self.g_X_2(s1, s2, lin, lout, pin)
                s1 = new_s1
                s2 = new_s2
        ans = self.gic_1(s1, s2)  # apply initial conditions
        return ans


    def G_Y_t(self, s1, s2, t, lin=8, lout=2, pin=0.05):
        """
        Calculates the generating function for the number of offsprings
        in a network with two communities at generation t conditioned on survival.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - t (int): Time point for which to calculate the generating function.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - ans (float): Value of the generating function for the number
                       of offsprings in the system at time t given its not a zero.
        """
        if t >= 0:
            # find the prob of process ending at t
            q_fun = self.G_N_t(0, 0, t, lin, lout, pin)

            # create pgf for G_Y_t by subtracting G_N_t_num and normalising it
            ans = (self.G_N_t(s1, s2, t, lin, lout, pin) - q_fun) / (1 - q_fun)
        else:
            ans = 0
        return ans

    # Hazard function
    def G_H_t(self, t, lin=8, lout=2, pin=0.05):
        """
        Hazard function for multi-type process on a network
        with two communities at generation t.

        Args:
        - s1 (float): dummy variable for type 1 offsprings.
        - s2 (float): dummy variable for type 2 offsprings.
        - t (int): Time point for which to calculate the generating function.
        - lin (float): average number of edges connecting nodes of type 2.
        - lout (float): average number of edges connecting nodes of type 1 to notes of type 2.
        - pin (float): Probability of an edge to be infected.

        Returns:
        - probs_both (float): probability of a process to die
                            at exactly generation t in entire network.
        - probs_1 (float): probability of a process to die
                          at exactly generation t in community 1.
        - probs_2 (float): probability of a process to die
                        at exactly generation t in community 2.
        """

        if t >= 0:
            probs_both = self.G_Y_t(self.g_X_1(0, 0, lin, lout, pin),
                                    self.g_X_2(0, 0, lin, lout, pin),
                                    t - 1, lin, lout, pin)
            probs_1 = self.G_Y_t(self.g_X_1(0, 1, lin, lout, pin),
                                 self.g_X_2(0, 1, lin, lout, pin),
                                 t - 1, lin, lout, pin)
            probs_2 = self.G_Y_t(self.g_X_1(1, 0, lin, lout, pin),
                                 self.g_X_2(1, 0, lin, lout, pin),
                                 t - 1, lin, lout, pin)
        else:
            probs_both, probs_1, probs_2 = 0, 0, 0
        return probs_both, probs_1, probs_2